package main

import (
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/safedep/vet/pkg/analyzer/filterv2"
)

var tmpl = template.Must(template.New("enums").Parse(`// Code generated by enumgen. DO NOT EDIT.

package {{ .PackageName }}

// getEnumConstantsMap returns a map of enum type names to their constant values
// This is used to expose enum constants to CEL expressions
func getEnumConstantsMap() map[string]any {
	return map[string]any{
{{- range .Enums }}
		"{{ .Name }}": map[string]int64{
{{- range .Values }}
			"{{ .Name }}": {{ .Value }},
{{- end }}
		},
{{- end }}
	}
}
`))

type enumValue struct {
	Name  string
	Value int64
}

type enumData struct {
	Name   string
	Values []enumValue
}

type templateData struct {
	PackageName string
	Enums       []enumData
}

func main() {
	var (
		outputFile  = flag.String("output", "enums_generated.go", "Output file path")
		packageName = flag.String("package", "filterv2", "Package name for generated code")
	)
	flag.Parse()

	// Read enum registrations from the filterv2 package
	registeredEnums := filterv2.RegisteredEnums

	if len(registeredEnums) == 0 {
		log.Fatal("No enums registered for generation")
	}

	data := templateData{
		PackageName: *packageName,
		Enums:       make([]enumData, 0, len(registeredEnums)),
	}

	for _, enumInfo := range registeredEnums {
		enumVals := processEnumRegistration(enumInfo)

		data.Enums = append(data.Enums, enumData{
			Name:   enumInfo.Name,
			Values: enumVals,
		})
	}

	// Generate code
	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	// Write to output file
	if err := os.WriteFile(*outputFile, formatted, 0o644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	fmt.Printf("Generated enum constants in %s\n", *outputFile)
}

// processEnumRegistration converts an EnumRegistration into enumValues
func processEnumRegistration(reg filterv2.EnumRegistration) []enumValue {
	values := make([]enumValue, 0, len(reg.ValueMap))

	for name, value := range reg.ValueMap {
		// Strip the common prefix if provided
		displayName := name
		if reg.Prefix != "" && strings.HasPrefix(name, reg.Prefix) {
			displayName = strings.TrimPrefix(name, reg.Prefix)
		}

		values = append(values, enumValue{
			Name:  displayName,
			Value: int64(value),
		})
	}

	// Sort by value for consistent output
	sort.Slice(values, func(i, j int) bool {
		return values[i].Value < values[j].Value
	})

	return values
}
