package scanner

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"buf.build/gen/go/safedep/api/grpc/go/safedep/services/malysis/v1/malysisv1grpc"
	malysisv1pb "buf.build/gen/go/safedep/api/protocolbuffers/go/safedep/messages/malysis/v1"
	packagev1 "buf.build/gen/go/safedep/api/protocolbuffers/go/safedep/messages/package/v1"
	malysisv1 "buf.build/gen/go/safedep/api/protocolbuffers/go/safedep/services/malysis/v1"
	"github.com/safedep/vet/pkg/common/logger"
	"github.com/safedep/vet/pkg/models"
	"google.golang.org/grpc"
)

type MalysisMalwareEnricherConfig struct {
	Timeout              time.Duration
	GrpcOperationTimeout time.Duration
	QueryWorkerCount     int
}

func DefaultMalysisMalwareEnricherConfig() MalysisMalwareEnricherConfig {
	return MalysisMalwareEnricherConfig{
		Timeout:              5 * time.Minute,
		QueryWorkerCount:     10,
		GrpcOperationTimeout: 5 * time.Second,
	}
}

type malysisMalwareEnricher struct {
	cc     *grpc.ClientConn
	client malysisv1grpc.MalwareAnalysisServiceClient
	config MalysisMalwareEnricherConfig

	// Cache of analysis identifiers to poll and apply the results
	// to all packages that were submitted for analysis. Malysis internally
	// maintains a cache for analysis result for a given package. It will
	// not re-analyse the package if it has already been analysed or submitted
	// for analysis.
	queryCache map[string][]*models.Package
	qcLock     sync.Mutex

	// Channel to submit analysis identifiers to the query worker
	queryChannel chan *analysisQueryRequest

	// Channel to push results by the query worker
	resultsChannel chan *analysisQueryResult
}

var _ PackageMetaEnricher = (*malysisMalwareEnricher)(nil)

type analysisSubmissionResult struct {
	analysisId string
}

type analysisQueryRequest struct {
	analysisId string
}

type analysisQueryResult struct {
	analysisId string
	response   *malysisv1.GetAnalysisReportResponse
	err        error
}

func NewMalysisMalwareEnricher(cc *grpc.ClientConn,
	config MalysisMalwareEnricherConfig) (*malysisMalwareEnricher, error) {
	if cc == nil {
		return nil, errors.New("grpc client connection is required")
	}

	ctx, cancelFn := context.WithTimeout(context.Background(), config.Timeout)
	go func() {
		_ = time.AfterFunc(config.Timeout+(1000*time.Millisecond), cancelFn)
	}()

	client := malysisv1grpc.NewMalwareAnalysisServiceClient(cc)
	enricher := &malysisMalwareEnricher{
		cc:             cc,
		client:         client,
		config:         config,
		queryCache:     make(map[string][]*models.Package),
		queryChannel:   make(chan *analysisQueryRequest, 10000),
		resultsChannel: make(chan *analysisQueryResult, 10000),
	}

	err := enricher.startResultWorker(ctx)
	if err != nil {
		cancelFn()
		return nil, fmt.Errorf("failed to start result worker: %w", err)
	}

	err = enricher.startQueryWorker(ctx)
	if err != nil {
		cancelFn()
		return nil, fmt.Errorf("failed to start query worker: %w", err)
	}

	return enricher, nil
}

func (e *malysisMalwareEnricher) Name() string {
	return "Malysis Malware Enricher"
}

// We will submit all packages for analysis because our backend has caching.
// This will ensure that eventually the packages will get analysed and
// subsequent scans will have better coverage in terms of malware analysis.
func (e *malysisMalwareEnricher) Enrich(pkg *models.Package,
	_ PackageDependencyCallbackFn) error {
	// Submit for analysis
	res, err := e.submitPackageForAnalysis(pkg)
	if err != nil {
		return fmt.Errorf("failed to submit package for analysis: %w", err)
	}

	// Add the analysis identifier to the cache for query go routine
	// to poll and apply the results to all packages that were submitted
	e.qcLock.Lock()
	defer e.qcLock.Unlock()

	if _, ok := e.queryCache[res.analysisId]; !ok {
		e.queryCache[res.analysisId] = make([]*models.Package, 0)
	}

	e.queryCache[res.analysisId] = append(e.queryCache[res.analysisId], pkg)
	e.enqueueAnalysisForQuery(res.analysisId)

	return nil
}

func (e *malysisMalwareEnricher) enqueueAnalysisForQuery(analysisId string) {
	e.queryChannel <- &analysisQueryRequest{analysisId: analysisId}
}

func (e *malysisMalwareEnricher) submitPackageForAnalysis(pkg *models.Package) (*analysisSubmissionResult, error) {
	logger.Infof("[Malware Analysis] Submitting package for malware analysis: %s/%s/%s",
		pkg.Manifest.Ecosystem, pkg.PackageDetails.Name, pkg.PackageDetails.Version)

	req := malysisv1.AnalyzePackageRequest{
		Target: &malysisv1pb.PackageAnalysisTarget{
			PackageVersion: &packagev1.PackageVersion{
				Package: &packagev1.Package{
					Ecosystem: pkg.GetControlTowerSpecEcosystem(),
					Name:      pkg.GetName(),
				},
				Version: pkg.GetVersion(),
			},
		},
	}

	ctx, cancelFn := context.WithTimeout(context.Background(), e.config.GrpcOperationTimeout)
	defer cancelFn()

	res, err := e.client.AnalyzePackage(ctx, &req)
	if err != nil {
		return nil, fmt.Errorf("failed to submit package for analysis: %w", err)
	}

	return &analysisSubmissionResult{analysisId: res.AnalysisId}, nil
}

// Receive results from query worker and apply to all packages.
// In case of error, re-submit for query.
func (e *malysisMalwareEnricher) startResultWorker(ctx context.Context) error {
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case res := <-e.resultsChannel:
				if res.err != nil {
					// What if a particular package analysis keeps failing?
					// How do we determine if the error is retryable?
					e.enqueueAnalysisForQuery(res.analysisId)
					continue
				}

				if res.response == nil {
					logger.Errorf("[Malware Analysis] Empty response for analysis: %s", res.analysisId)
					continue
				}

				if res.response.GetReport() == nil {
					logger.Errorf("[Malware Analysis] Empty report for analysis: %s", res.analysisId)
					continue
				}

				// Apply the results to all packages that were submitted for analysis
				e.qcLock.Lock()
				if packages, ok := e.queryCache[res.analysisId]; ok {
					for _, pkg := range packages {
						// Apply the results to the package
						logger.Debugf("[Malware Analysis] Applying results to package: %s/%s/%s",
							pkg.Manifest.GetControlTowerSpecEcosystem(), pkg.GetName(), pkg.GetVersion())

						// Here we only enrich the package with the malware analysis result.
						// We do not make a decision based on the result.
						pkg.SetMalwareAnalysisResult(&models.MalwareAnalysisResult{
							AnalysisId: res.analysisId,
							Report:     res.response.GetReport(),
						})
					}
				}
				e.qcLock.Unlock()
			}
		}
	}()

	return nil
}

// Poll the result for a given analysisId
func (e *malysisMalwareEnricher) startQueryWorker(ctx context.Context) error {
	for i := 0; i < e.config.QueryWorkerCount; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					return
				case req := <-e.queryChannel:
					ctx, cancelFn := context.WithTimeout(context.Background(), e.config.GrpcOperationTimeout)
					defer cancelFn()

					res, err := e.client.GetAnalysisReport(ctx, &malysisv1.GetAnalysisReportRequest{
						AnalysisId: req.analysisId,
					})

					// Check for incomplete analysis
					if (res != nil) && err == nil {
						// If the analysis explicitly failed at the service provider, we will
						// log the error and will NOT retry the polling.
						if res.Status == malysisv1.AnalysisStatus_ANALYSIS_STATUS_FAILED {
							logger.Errorf("[Malware Analysis] Analysis Id: %s failed with error: %s",
								req.analysisId, res.GetErrorMessage())
							continue
						}

						// For any other status, we will retry the polling by returning
						// an error to the results channel.
						if res.Status != malysisv1.AnalysisStatus_ANALYSIS_STATUS_COMPLETED {
							err = fmt.Errorf("analysis is not completed: %s", res.Status)
						}
					}

					e.resultsChannel <- &analysisQueryResult{
						analysisId: req.analysisId,
						response:   res,
						err:        err,
					}
				}
			}
		}()
	}

	return nil
}
