package tools

import (
	"context"
	"fmt"

	mcpgo "github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"github.com/safedep/dry/api/pb"
	"github.com/safedep/vet/mcp"
	"github.com/safedep/vet/pkg/common/logger"
)

// vulnerabilityTool provides direct vulnerability querying functionality
type vulnerabilityTool struct {
	driver mcp.Driver
}

var _ mcp.McpTool = &vulnerabilityTool{}

// NewVulnerabilityTool creates a new instance of vulnerabilityTool
func NewVulnerabilityTool(driver mcp.Driver) *vulnerabilityTool {
	return &vulnerabilityTool{
		driver: driver,
	}
}

// Register registers the tool with the MCP server
func (t *vulnerabilityTool) Register(server *server.MCPServer) error {
	vulnerabilityOnlyTool := mcpgo.NewTool("get_vulnerabilities",
		mcpgo.WithDescription("Get vulnerabilities for a package version using the dedicated vulnerabilities API"),
		mcpgo.WithString("purl", mcpgo.Required(), mcpgo.Description("The package URL to get vulnerabilities for")),
	)

	server.AddTool(vulnerabilityOnlyTool, t.executeGetVulnerabilities)

	return nil
}

func (t *vulnerabilityTool) executeGetVulnerabilities(ctx context.Context,
	req mcpgo.CallToolRequest,
) (*mcpgo.CallToolResult, error) {
	purl, err := req.RequireString("purl")
	if err != nil {
		return nil, fmt.Errorf("purl is required: %w", err)
	}

	parsedPurl, err := pb.NewPurlPackageVersion(purl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse purl: %w", err)
	}

	logger.Debugf("Getting vulnerabilities for package: %s", purl)

	vulns, err := t.driver.GetPackageVersionVulnerabilitiesOnly(ctx, parsedPurl.PackageVersion())
	if err != nil {
		return nil, fmt.Errorf("failed to get package vulnerabilities: %w", err)
	}

	logger.Debugf("Found %d vulnerabilities for package: %s", len(vulns), purl)

	vulnsJson, err := serializeForLlm(vulns)
	if err != nil {
		return nil, fmt.Errorf("failed to serialize vulnerabilities: %w", err)
	}

	return mcpgo.NewToolResultText(vulnsJson), nil
}