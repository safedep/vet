package tools

import (
	"context"
	"testing"

	vulnerabilityv1 "buf.build/gen/go/safedep/api/protocolbuffers/go/safedep/messages/vulnerability/v1"
	"github.com/safedep/vet/mcp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestVulnerabilityTool_ExecuteGetVulnerabilities(t *testing.T) {
	tests := []struct {
		name           string
		purl           string
		setupMock      func(driver *MockDriver)
		expectedError  string
		expectedResult bool
	}{
		{
			name: "successful vulnerabilities retrieval",
			purl: "pkg:npm/express@4.18.0",
			setupMock: func(driver *MockDriver) {
				vulns := []*vulnerabilityv1.Vulnerability{
					{
						Id: &vulnerabilityv1.VulnerabilityIdentifier{
							Value: "CVE-2022-24999",
						},
						Summary: "High severity vulnerability",
					},
				}
				driver.On("GetPackageVersionVulnerabilitiesOnly", mock.Anything, mock.AnythingOfType("*packagev1.PackageVersion")).Return(vulns, nil)
			},
			expectedResult: true,
		},
		{
			name:          "missing purl parameter",
			purl:          "",
			setupMock:     func(driver *MockDriver) {},
			expectedError: "failed to parse purl",
		},
		{
			name:          "invalid purl format",
			purl:          "invalid-purl",
			setupMock:     func(driver *MockDriver) {},
			expectedError: "failed to parse purl",
		},
		{
			name: "package version not found",
			purl: "pkg:npm/nonexistent@1.0.0",
			setupMock: func(driver *MockDriver) {
				driver.On("GetPackageVersionVulnerabilitiesOnly", mock.Anything, mock.AnythingOfType("*packagev1.PackageVersion")).Return(nil, mcp.ErrPackageVersionInsightNotFound)
			},
			expectedError: "failed to get package vulnerabilities",
		},
		{
			name: "driver returns other error",
			purl: "pkg:npm/express@4.18.0",
			setupMock: func(driver *MockDriver) {
				driver.On("GetPackageVersionVulnerabilitiesOnly", mock.Anything, mock.AnythingOfType("*packagev1.PackageVersion")).Return(nil, assert.AnError)
			},
			expectedError: "failed to get package vulnerabilities",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mock driver
			mockDriver := NewMockDriver()
			tt.setupMock(mockDriver)

			// Create the tool
			tool := NewVulnerabilityTool(mockDriver)

			// Create request
			req := createCallToolRequest("get_vulnerabilities", map[string]interface{}{
				"purl": tt.purl,
			})

			// Execute the function
			result, err := tool.executeGetVulnerabilities(context.Background(), req)

			// Verify results
			if tt.expectedError != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				if tt.expectedResult {
					assert.NotNil(t, result)
					assert.NotEmpty(t, result.Content)
				}
			}

			// Verify all expectations were met
			mockDriver.AssertExpectations(t)
		})
	}
}

func TestVulnerabilityTool_Register(t *testing.T) {
	// This test verifies that the tool can be created without errors
	// Full registration testing would require mocking the MCP server

	mockDriver := NewMockDriver()
	tool := NewVulnerabilityTool(mockDriver)

	assert.NotNil(t, tool)
	assert.Equal(t, mockDriver, tool.driver)
}